---
title: "Executing business rules at scale using RDrools - an interface to Drools"
author: "Naren Srinivasan, Dheekshitha PS"
date: "6/19/2018"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Executing business rules at scale using RDrools - an interface to Drools}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r echo = FALSE, message = FALSE, results = 'hide', warning = FALSE, error=FALSE}
#Package installation if required for handbook
required.packages <- c('Rdrools','DT','lubridate','purrr','dplyr')

for(pkg in required.packages){
  if(!require(pkg,character.only = T)){
    install.packages(pkg, repos = "http://cloud.r-project.org/")
    library(pkg)
  }
}

```

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
#library(Rdrools)
#library(purrr)
source("../R/Rdrools.R")
source("../../Rdroolsjars/R/onLoad.R")
options(stringsAsFactors = F)
```

# Introduction

## Objectives of *Rdrools*

The Rdrools package aims to accomplish two main objectives:

* Allow data scientists an intuitive interface to **execute business rules on datasets for the purpose of analysis or designing intelligent systems**, while leveraging the Drools rule engine
* Provide a direct interface to *Drools* for executing all types of rules defined in *Drools* formats - *.drl* and *.dt*

## The advantages of a rule engine

Rule engines allow for optimal checking of rules against data for large rule sets [of the order of hundreds or even thousands of rules]. *Drools* [and other rule engines] implement an enhanced version of the **Rete algorithm**, which efficiently match **facts** [data tuples] against **conditions** [rules]. This allows for codifying intuition/ business context which can be used to power intelligent systems.

## Why Rdrools

RDrools brings the efficiencies of large scale production rule systems to data science users. Rule sets can be used alone, or in conjunction with machine learning models, to develop and operationalize intelligent systems. RDrools allows for deployment of rules defined through an R interface into a production system. As data comes in [periodic or real-time], a pre-defined set of rules can be checked on the data, and actions can be triggered based on the result

# Running rules on **Rdrools**

## Executing rules on a dataset

In order to achieve the objective of providing data scientists an intuitive interface to execute rules on datasets, the Rdrools package exposes the *executeRulesOnDataset* function, which is explicitly designed for data scientists. As input to this function rules are defined using the typical language of data science with verbs such as
* *filter*
* *group by*
* *aggregate*

Additionally, defined rules can be executed as a sequence, with the result of one rule feeding into another

For ease of use, the rules can be defined in a *csv* format, with a familiar structure using the verbs discussed earlier. We take the example of the iris dataset and define rules on it. The sample rules for the iris dataset are defined in the *irisRules.csv*

```{r}
data(iris)

sampleRules <- read.csv("../data/SampleRules/irisRules.csv")
rownames(sampleRules) <- seq(1:nrow(sampleRules))
sampleRules[is.na(sampleRules)]    <-""
sampleRules
```

Through this function, various typical types of rules can be executed as combination of the **verbs** described above.

### Applying a simple filter

The first type of rule is applying a simple filter based on condition on a particular column. This is done by specifying the full condition under the filter column.

In the case of the **iris** dataset, we filter out a specific type of *Species*. To illustrate this case, we apply only rule 1.

```{r}
filterRule <- sampleRules[1,]
filterRuleOutput <- executeRulesOnDataset(iris, filterRule)
str(filterRuleOutput)
```

The output has three objects:  

* input: has the rule defined  by the user in a dataframe
* intermediateOutput : intermediate output especially in case of sequential rules
* output: has the output dataframe with 3 columns:
    * Group: the above rule has no group by and hence the rule is applied row wise. Group in this case represents the row number
    * Indices: the row numbers of the dataframe
    * IsTrue: flag to say if the datapoint is satisfying the rule or not. IN this case, Flag is *true* if the Species is setosa and *false* if it's not setosa



### Applying a condition on aggregated grouped data

The second type of rule is to apply a condition on the aggregated value of metric for diffferent groups. In the case of the **iris** dataset, we aggregate the *Sepal.Length* variable across different *Species*, and identify the *Species* which have an average *Sepal.Length* greater than a threshold value. 

To illustrate this case, we apply only rule 2 from the set of sample rules.

```{r}
groupedAggregationRule <- sampleRules[2,]
groupedAggregationRuleOutput <- executeRulesOnDataset(iris, groupedAggregationRule)
str(groupedAggregationRuleOutput)
```

The output has three objects:
  
* input: has the rule defined  by the user in a dataframe
* intermediateOutput : intermediate output especially in case of sequential rules
* output: has the output dataframe with 3 columns:
    * Group: the above rule has group by and hence the rule is applied on each group. Group in this case represents the column groupedby, Species
    * Indices: the row numbers of each group
    * IsTrue: flag to say if the datapoint is satisfying the rule or not. IN this case, Flag is *true* if the aggregated value is greater than or equal to .5.9 and *false* if it's not



### Applying an aggregation on a column

This type of rule allows the data scientist to aggregate an entire column and compare that with a threshold value.
In the case of the **iris** dataset, we aggregate the *Sepal.Length* variable across all cases, and check if it is less than a threshold value

To illustrate this case, we apply only rule 3 from the set of sample rules.


```{r}
columnAggregationRule <- sampleRules[3,]
columnAggregationRuleOutput <- executeRulesOnDataset(iris, columnAggregationRule)
str(columnAggregationRuleOutput)
```

The output has three objects:

* input: has the rule defined  by the user in a dataframe
* intermediateOutput : intermediate output especially in case of sequential rules
* output: has the output dataframe with 3 columns:
    * Group: the above rule has no group by and no filter. The rule is applied on the whole column. Group in this case represents the whole column
    * Indices: the row numbers of the whole dataframe
    * IsTrue: flag to say if the datapoint is satisfying the rule or not. IN this case, Flag is *true* if the aggregated value is greater than 5 and *false* if it's not

### Applying a filter with aggregation

In this case, we apply a filter, and then on the filtered data, aggregate a column and compare it to a threshold value. In the case of the **iris** dataset, we we check if for cases with *Sepal.Width* > 3, if the average *Sepal.Length* is greater than 5

To illustrate this case, we apply only rule 4 from the set of sample rules.

```{r}
filterColAggregationRule <- sampleRules[4,]
filterColAggregationRuleOutput <- executeRulesOnDataset(iris, filterColAggregationRule)
str(filterColAggregationRuleOutput)
```

The output has three objects:

* input: has the rule defined  by the user in a dataframe
* intermediateOutput : intermediate output especially in case of sequential rules
* output: has the output dataframe with 3 columns:
    * Group: the above rule has no group by and hence the rule is applied on whole column after filtering the data. Group in this case represents the whole column 
* Indices: the row numbers of the whole dataframe
    * IsTrue: flag to say if the datapoint is satisfying the rule or not. In this case, Flag is *true* if the aggregated value of the filtered data is greater than or equal to 5  and *false* if it's not
    
### Applying a filter with grouped aggregation

We now combine all types if verbs into one rule. In *iris* dataset, we check if for all cases with *Petal.Width* greater than a threshold value, if each type of *Species* [which is a group] has an average *Petal.Length* greater than another threshold.

To illustrate this case, we apply only rule 5 from the set of sample rules.

```{r}
filterGroupByAggrRule <- sampleRules[5,]
filterGroupByAggrRuleOutput <- executeRulesOnDataset(iris, filterGroupByAggrRule)
str(filterGroupByAggrRuleOutput)
```

The output has three objects:

* input: has the rule defined  by the user in a dataframe
* intermediateOutput : intermediate output especially in case of sequential rules
* output: has the output dataframe with 3 columns:
    * Group: the above rule has group by and filter. Hence the rule is applied on each group after filtering the data. Group in this case represents the groupedby column, Species
* Indices: the row numbers of the each group
    * IsTrue: flag to say if the datapoint is satisfying the rule or not. In this case, Flag is *true* if the aggregated value of the filtered data is less than or equal to 5  and *false* if it's not


# Use case

## Problem statement

Consider the customers of a retail bank, who make transactions against their bank account for different purposes such as shopping, money transfers, etc. In the banking system, there is a huge potential for fraud, with abnormal transaction behavior indicative of this. 

We explore how such transactions can be monitored intelligently to detect fraud using Rdrools by applying business rules.

## Details of the dataset 

The following dataset provides transaction data for multiple customers of the retail bank (identified by their *Account IDs*) is used. Every transaction that a user (account) does is recorded with the following details:

  + *Transaction ID*: unique code for each transaction
  + *Transaction Amount*: the amount debited or credited in each transaction
  + *trans_tender_type*: tells if the transaction is a deposit or loan repayment or if it is an overseas transaction                       
  + *Credit card details*: the monthly credit card expenditure 
  + *Transaction_Channel*: the mode of transaction like ATM or card swipe etc
  + *Balance*: the amount in the account after each transaction
  + *Total transactions*: number of transactions done by the customer in each month and the cumulative number of transactions

```{r,warning=FALSE}
transactionData <- read.csv("/home/dheekshitha/Desktop/Rdrools_Dev/Rdrools/src/main/resources/Rdrools/data/SampleDataset/TransactionsData.csv",stringsAsFactors = F)
transactionData$Date <- ymd(transactionData$Date)
transactionData <- transactionData[1:500,]
```

## Displaying a sample (top 10 rows) of the uploaded dataset

```{r,echo=FALSE,warning=FALSE}
datatable(
  head(transactionData, 20), extensions = 'FixedColumns',
  options = list(
  dom = 't',
  scrollX = TRUE,
  scrollCollapse = TRUE
))
```


------
```{r,echo=FALSE}
str(transactionData)

```

------



## Defining the rules file

There might be certain cases where we simply want to check the behavior of customers based on a constant benchmark value. These might be cases such as compliance and policy violations, etc. 

In our case we check rules like:


  + If the number of transactions done by the customer in a month exceeds more than 20 then the customer can be fraudulent
  + If the transaction amount exceeds the more than a threshold then the account can be fraudulent
  


```{r}
transactionRules <- read.csv("/home/dheekshitha/Desktop/Rdrools_Dev/Rdrools/src/main/resources/Rdrools/data/SampleRules/workingRules.csv")
rownames(transactionRules) <- seq(1:nrow(transactionRules))
transactionRules[is.na(transactionRules)]    <-""
transactionRules

```

One example of the rules to mark anomalous transactions from the above list is

$$\textsf{For an account, the total Transaction_Amount } \\  \textsf{should be greater than or equal to USD 40,000}$$ 



## Executing rules on dataset

The rules can be executed on the transaction data as follows.
```{r}

transactionDataOutput  <- executeRulesOnDataset(transactionData, transactionRules)

```

## Viewing results

```{r,message=NA}
str(transactionDataOutput[[5]])
```
 Let us take the results obtained for *Rule5* to understand the applications of Rdrools. The *Rule5* was

$$\textsf{For an account, the maximum of Transaction_Amount } \\  \textsf{should be greater than or equal to USD 40,000 for all the debit transactions done after 2017-05-01}$$ 
The output has three objects:

* input: has the rule defined  by the user in a dataframe
* intermediateOutput : intermediate output especially in case of sequential rules
* output: has the output dataframe with 3 columns:
    * Group: 
    The rule says to find the transactions done by each *Account_ID*, which implies that the data is to be groupedby *Account_Id*. Hence group here represents the *Account_ID*.
    * Indices: the row numbers of the dataframe under each *Account_ID* 
    * IsTrue: flag to say if the *Account_ID* is anomalous or not. 


# References

[Drools Documentation](https://docs.jboss.org/drools/release/6.2.0.CR1/drools-docs/html_single/)

[Rdrools Documentation]( https://cran.r-project.org/web/packages/Rdrools/Rdrools.pdf )